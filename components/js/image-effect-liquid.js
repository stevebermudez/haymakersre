"use strict";(globalThis.webpackChunk_websiteComponents=globalThis.webpackChunk_websiteComponents||[]).push([[3881],{96071(e,n,t){t.d(n,{t:()=>a});var o=t(78677),i=t(33814),r=t(80401);const s=e=>!(!e.complete||!e.src);class a{constructor(e){let{imageNode:n,containerNode:t,effectProps:a,WebGLComponent:c}=e;(0,o.A)(this,"currentImageSrc",""),(0,o.A)(this,"onPrefersReducedMotionChange",e=>{e?this.destroyComponent():this.prepareImage()}),(0,o.A)(this,"onContainerResize",()=>{var e;null===(e=this.componentManager)||void 0===e||e.refresh()}),(0,o.A)(this,"onImageLoaded",()=>{var e;this.currentImageSrc=this.imageNode.src,this.componentManager?this.componentManager.setProps({image:this.imageNode,imageNeedsUpdate:!0}):this.componentManager=new i.A(this.WebGLComponent,this.containerNode,{image:this.imageNode,pixelRatio:(null===(e=window)||void 0===e?void 0:e.devicePixelRatio)||1,...this.effectProps,focalPoint:this.getFocalPoint()},{scrollWindowRef:window,normalizeScroll:!1})}),(0,o.A)(this,"updateImage",e=>{this.componentManager&&(this.imageNode===e&&this.currentImageSrc===e.src||(this.imageNode.removeEventListener("load",this.onImageLoaded),this.imageNode=e,this.imageNode.addEventListener("load",this.onImageLoaded),s(this.imageNode)&&this.componentManager.setProps({image:this.imageNode,imageNeedsUpdate:!0})))}),(0,o.A)(this,"updateProps",e=>{this.componentManager&&this.componentManager.setProps(e)}),(0,o.A)(this,"getType",()=>{var e;return null===(e=this.componentManager)||void 0===e||null===(e=e.props)||void 0===e?void 0:e.type}),(0,o.A)(this,"destroy",()=>{this.destroyComponent(),this.removeListeners()}),this.imageNode=n,this.containerNode=t,this.effectProps=a,this.WebGLComponent=c,r.A&&(this.prefersReducedMotionHandler=((e,n)=>{const t=window.matchMedia("(prefers-reduced-motion: reduce)"),o={},i=((e,n)=>(e.addEventListener?e.addEventListener("change",n):e.addListener(n),n))(t,e=>{o.matches=e.matches,null==n||n(o.matches)});return o.matches=t.matches,o.destroy=()=>{((e,n)=>{e.removeEventListener?e.removeEventListener("change",n):e.removeListener(n)})(t,i)},o})(0,this.onPrefersReducedMotionChange),this.prefersReducedMotionHandler.matches||this.prepareImage())}prepareImage(){this.imageNode.addEventListener("load",this.onImageLoaded),this.imageNode.style.visibility="hidden",s(this.imageNode)&&this.onImageLoaded()}getFocalPoint(){if(this.effectProps.focalPoint)return this.effectProps.focalPoint;const[e,n]=window.getComputedStyle(this.imageNode).objectPosition.split(" ");return{x:parseFloat(e)/100,y:parseFloat(n)/100}}destroyComponent(){var e;null===(e=this.componentManager)||void 0===e||e.destroy(),this.componentManager=void 0,this.imageNode&&(this.imageNode.style.visibility="",this.imageNode.removeEventListener("load",this.onImageLoaded))}removeListeners(){var e,n;null===(e=this.prefersReducedMotionHandler)||void 0===e||null===(n=e.destroy)||void 0===n||n.call(e)}}},19506(e,n,t){t.r(n),t.d(n,{default:()=>l}),t(41427),t(64648),t(36027),t(78382),t(88792),t(49347),t(87241),t(90620);var o=t(39551),i=t(42363),r=t(59596),s=t(84264),a=t(83279),c=t(78677);function m(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter(function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable})),t.push.apply(t,o)}return t}function d(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?m(Object(t),!0).forEach(function(n){(0,c.A)(e,n,t[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):m(Object(t)).forEach(function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))})}return e}function v(e,n,t){return n=(0,s.A)(n),(0,r.A)(e,u()?Reflect.construct(n,t||[],(0,s.A)(e).constructor):n.apply(e,t))}function u(){try{var e=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){}))}catch(e){}return(u=function(){return!!e})()}var p=function(e){function n(e,t){return(0,o.A)(this,n),v(this,n,[e,d({programKey:"liquid-program",frag:"\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_2497077985(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_2497077985(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_2497077985(vec4 x) {\n     return mod289_2497077985(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_2497077985(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D_2497077985 = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g_2497077985 = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g_2497077985;\n  vec3 i1 = min( g_2497077985.xyz, l.zxy );\n  vec3 i2 = max( g_2497077985.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D_2497077985.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289_2497077985(i);\n  vec4 p = permute_2497077985( permute_2497077985( permute_2497077985(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D_2497077985.wyz - D_2497077985.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1_2497077985 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0_2497077985 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1_2497077985.xy,h.z);\n  vec3 p3 = vec3(a1_2497077985.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt_2497077985(vec4(dot(p0_2497077985,p0_2497077985), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0_2497077985 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0_2497077985,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\nfloat ease(float t) {\n  float f = t - 1.0;\n  return f * f * f + 1.0;\n}\n\nuniform float uComplexity;\nuniform float uDirection;\nuniform float uIntensity;\nuniform float uSeed;\nuniform float uShadow;\nuniform float uSmoothness;\nuniform float uTime;\nuniform float uMorphTime;\nuniform sampler2D uImage;\n\nvarying vec2 vUv;\n\nvec2 rotate(vec2 uv,float amount){\n  float ca = cos(amount);\n  float sa = sin(amount);\n\n  return vec2(\n    uv.x * ca + uv.y * sa,\n    -uv.x * sa + uv.y * ca\n  );\n}\n\nfloat getNoise(vec2 uv) {\n  vec2 direction = rotate(vec2(uTime), uDirection);\n\n  return 1.0 - snoise(vec3(uv * uComplexity + direction, uMorphTime) + uSeed);\n}\n\nvoid main (void) {\n  float noise = 1.0 - ease(smoothstep(1.0 - uSmoothness, 1.0, 1.0 - getNoise(vUv))) * uIntensity;\n  float shadow = smoothstep(1.0 - uIntensity, 1.0, noise) * uShadow * 0.5;\n  vec2 uv = (vUv - 0.5) * noise + 0.5;\n\n  vec4 tx = texture2D(uImage, uv);\n  tx.xyz *= tx.a;\n\n  gl_FragColor = tx - vec4(vec3(shadow), 0.0);\n}\n",uniforms:{uTime:0,uMorphTime:0}},t)])}return(0,a.A)(n,e),(0,i.A)(n,[{key:"getUniformsFromProps",value:function(){var e=this.props,n=e.scale,t=e.rotation,o=e.intensity,i=e.seed,r=e.shadow,s=e.smoothness;return{uComplexity:n,uDirection:(45+t)*(Math.PI/180),uIntensity:.01*o,uSeed:i,uShadow:.01*r,uSmoothness:.01*s}}},{key:"update",value:function(){this.uniforms.uTime+=5e-5*this.props.speed,this.uniforms.uMorphTime+=1e-4*this.props.morphSpeed}}])}(t(17699).A);(0,c.A)(p,"defaultProps",{scale:0,rotation:0,intensity:0,morphSpeed:0,seed:0,shadow:0,smoothness:0,speed:0});var h=t(96071);class l extends h.t{constructor(e){super({...e,WebGLComponent:p})}}}}]);